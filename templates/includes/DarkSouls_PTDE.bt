//--------------------------------------
//--- 010 Editor v5.0 Binary Template
//
// File: DRAKS0005.sl2
// Author: Tarvitz
// Revision: 0.0.1
// Purpose: 4 fun
//--------------------------------------
#include "bnd4.bt";
#include "character.bt";
#include "backpack.bt"
#include "unknown.bt";

typedef struct{
    ubyte flag1 : 1 ;
    ubyte flag2 : 1 ;
    ubyte flag3 : 1 ;
    ubyte flag4 : 1 ;
    ubyte flag5 : 1 ;
    ubyte flag6 : 1 ;
    ubyte flag7 : 1 ;
    ubyte flag8 : 1 ;
} BitFlags;

typedef struct{
    float R;
    float G;
    float B;
    float A;
} Color;

typedef struct{
    byte md5[16];
} Checksum <bgcolor=cLtGreen>;

typedef struct{
   ubyte UnknownData3[50] <bgcolor=cLtYellow>;
// I suspect the character creation options can be found around here
   ubyte skintone;
   byte UnknownData4[57] <bgcolor=cLtYellow>;
} CharacterParams;

typedef struct{
    Item magic;
    uint count;
} Attuned;

// I'm not sure exactly how these map, if they are just shorts or UnknownTuple
typedef struct{
    UnknownTuple unknown1 <bgcolor=cLtYellow>;
    UnknownTuple petrus <comment="shrug - 21, look skyward - 23, unlearned - 20">;
    UnknownTuple unknown3 <bgcolor=cLtYellow>;
    UnknownTuple unknown4 <bgcolor=cLtYellow>;
} LearnedGestures;

typedef struct{
    UnknownTuple UnknownData5a[10] <bgcolor=cLtYellow>;
    // equipped gestures are stored somewhere else, this is specifically if they are available or not
    // enabling this wont remove the speak option and vice verse
    LearnedGestures gestures;
    //maybe more gestures?
    UnknownTuple UnknownData5b[4] <bgcolor=cLtYellow>;
    uint ZeroPad[16] <bgcolor=cWhite>;
} Gestures;

typedef struct{
    uint ChrHeaderLength;
    byte ChrHeader[ChrHeaderLength]; // some bytes in here definitely track enemy deaths
    // the case I tested was writing byte 30 and 34, which made some enemies in the level spawn dead.

    uint ObjHeaderLength;
    byte ObjHeader[ObjHeaderLength]; // broken objects tracker?
    byte TrailingData[88];

    // there are more containers inside these containers that follow the
    // UnknownOnline struct pattern, where the first uint declare their size.

    UnknownOnline unknownContainer[14]<optimize=false>;
       //the container with index 7: orange soapstone messages?
       // index 8: bloodstain animations?
       // index 10 is something as well.
} OnlineData;

typedef struct{
  uint bonfireenabled1 : 1 ;
  uint bonfireenabled2 : 1 ;
  uint bonfireenabled3 : 1 ;
  uint bonfireenabled4 : 1 ;
  uint bonfireenabled5 : 1 ;
  uint bonfireenabled6 : 1 ;
  uint bonfireenabled7 : 1 ;
  uint bonfireenabled8 : 1 ;
  uint bonfireenabled9 : 1 ;
  uint bonfireenabled10 : 1 ;
  uint bonfireenabled11 : 1 ;
  uint bonfireenabled12 : 1 ;
  uint bonfireenabled13 : 1 ;
  uint bonfireenabled14 : 1 ;
  uint bonfireenabled15 : 1 ;
  uint bonfireenabled16 : 1 <comment="firelink?">; // enables when arriving at firelink first time
  uint bonfireenabled17 : 1 ;
  uint bonfireenabled18 : 1 ;
  uint bonfireenabled19 : 1 ;
  uint bonfireenabled20 : 1 ;
  uint bonfireenabled21 : 1 ;
  uint bonfireenabled22 : 1 ;
  uint bonfireenabled23 : 1 ;
  uint bonfireenabled24 : 1 ;
  uint bonfireenabled25 : 1 ;
  uint bonfireenabled26 : 1 ;
  uint bonfireenabled27 : 1 ;
  uint bonfireenabled28 : 1 ;
  uint bonfireenabled29 : 1 ;
  uint bonfireenabled30 : 1 ;
  uint bonfireenabled31 : 1 ;
  uint bonfireenabled32 : 1 ;
} Bonfires;

typedef struct{
    uint unknown[4];
    byte UnknownData8b[38-20] <bgcolor=cLtYellow>;
    Bonfires enabledBonfires<bgcolor=cLtGreen>; // not tested enough
    byte unknown2[214] <bgcolor=cLtYellow>;
    byte filler[788] <bgcolor=cWhite>;
    byte unknown3[224] <bgcolor=cLtYellow>;
    byte filler2[16] <bgcolor=cWhite>;
} BonfireSection;

typedef struct {
    local int unknown_size_1 = sizeof(StatsUnknown1);
    local int stats_size = sizeof(Stats);
    local int pack_size = sizeof(Pack);
    local int backpack_amount = 2048; // is this hard code constant? // i dont know, we could try filling the backpack 
// with 2047 items and se what happens when we try to pick up another. if it refuses its constant, if it dynamically resize the 
// pack then we know


    Checksum header; // this is written after the md5 in the footer of the save slot is written, it includes all parts of the save slot except for the ChecksumHeader
    uint length; //number of bytes that should be included in the checksum, 393216 ( entire slot is 393248 )
    StatsUnknown1 unknown <comment="unknown data">;

    Stats stats;
    Pack pack;

    uint backpack_items_amount;
    uint backpack_keys_amount;
    uint backpack_size;
    // 0-63 indexes for utils box
    local uint utilbox_size = 64;
    local uint itembox_size = backpack_size - utilbox_size;

    //warning, if you've dropped an item, there may be blank items interleaved among the existing
    //items and some items will be pushed into the empty part of the box display
    PartiallyUsedBox util_box(utilbox_size,backpack_keys_amount);
    PartiallyUsedBox item_box(itembox_size,backpack_items_amount);

    uint lastindex; // the item with the highest index // whatever that means? not tested
    Attuned attunementslots[12];
    uint UnknownData1;

    uint equippedItems[5]; // could these also be the index-remember-previous-selection feature?

    UnknownTuple UnknownData2[10]<bgcolor=cLtYellow>;

    Color hair; // @ address: 0xE644
    Color eye; 
    CharacterParams creationdata;

    BottomlessBox box[backpack_amount];

    Gestures gestures;

    // the end part of the playthrough counter looks like it is almost in a box struct?
    UnknownBlob1 playthrough_counter;
    UnknownBox unknown_box[64];
    UnknownStruct unknown_box_2[120];

    UnknownBlob2 counters;


    // a section has length 0x500
    BonfireSection firstsection;
    UnknownBulkSection unknownSections[72];
    //unknownSection[2].marker[8] includes the bit that unlocks the undead burg ladder shortcut. it is bit 0x08 if my calculations are correct

    byte zerofill2[10] <bgcolor=cWhite,fgcolor=cGreen>;

    local uint mark = FTell();

    OnlineData online;

    // Here we have a dynamic length zero pad, skip to next part with numbers
    FSeek(mark+131242);

    //0x56280 burg bonfire?
    UnknownArea areadata[2578] <bgcolor=cLtYellow>; //Im getting indications that this is just garbage data?

    Checksum secondary; // this is the md5 checksum of all bytes in this save slot, excluding the header and the length fields
    ubyte offset[12] <bgcolor=cWhite>;
} SaveSlot;

LittleEndian(); 

local uint tag = ReadUInt( FTell() );

// IDENTIFY BND4 token
// this is 0x20434f43 for x360 saves (coc?)
// another tag for x360 is at 0x360: 3a084d4e (little endian)
if( tag != 0x34444e42)
{
    Warning("Not a Dark Souls prepare to die edition file save format");
    return -1;
}

SetBackColor( cLtGray );
BND4 meta;

// slots should be configurated according to record's dsContainersAmount // not really, what if you've deleted slot 1 but slot 2 exists?
if (meta.SlotMetaBlockSize != 0x20)
{
    Warning("Not a Dark Souls prepare to die edition file save format");
    return -1;
}

local uint slots = 0;
local uint test = 0;
for( slots = 0; slots < 10; slots++ )
{
    // if totalhp stat is zero, this is not a valid save slot
    test = ReadUInt( FTell() + 116 );
    if( test != 0 )
        SaveSlot slot;
    else
        FSeek( FTell() + 0x60020 );
}
